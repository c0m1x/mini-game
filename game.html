<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Survival Arena</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at center, #0a0f2c, #000);
      overflow: hidden;
      font-family: "Segoe UI", sans-serif;
    }

    #ui {
      position: fixed;
      top: 15px;
      left: 20px;
      color: #00ffff;
      font-size: 18px;
      text-shadow: 0 0 10px #00ffff;
    }

    #ammoDisplay {
      position: fixed;
      bottom: 30px;
      right: 30px;
      color: #fff;
      font-size: 48px;
      font-weight: bold;
      text-shadow: 0 0 15px #00ffff, 2px 2px 4px #000;
    }

    #ammoDisplay.low {
      color: #ff3333;
      text-shadow: 0 0 20px #ff0000, 2px 2px 4px #000;
    }

    #scoreboard {
      position: fixed;
      top: 15px;
      right: 20px;
      background: rgba(10, 15, 44, 0.8);
      border: 2px solid #00ffff;
      padding: 15px;
      color: #fff;
      font-size: 14px;
      min-width: 200px;
    }

    #scoreboard h3 {
      margin: 0 0 10px 0;
      color: #00ffff;
      text-align: center;
      font-size: 18px;
      text-shadow: 0 0 10px #00ffff;
    }

    .score-entry {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid #333;
    }

    .score-entry:last-child {
      border-bottom: none;
    }

    #upgradeMenu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(10, 15, 44, 0.95);
      border: 3px solid #00ffff;
      padding: 30px;
      color: #fff;
      font-size: 20px;
      text-align: center;
      box-shadow: 0 0 30px #00ffff;
      display: none;
      z-index: 100;
    }

    #upgradeMenu button {
      background: #00ffff;
      border: none;
      padding: 15px 30px;
      margin: 10px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      color: #000;
      border-radius: 5px;
      transition: all 0.3s;
    }

    #upgradeMenu button:hover {
      background: #00cccc;
      transform: scale(1.05);
    }

    #bossWarning {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(139, 0, 0, 0.95);
      border: 5px solid #ff0000;
      padding: 40px 60px;
      color: #fff;
      font-size: 48px;
      font-weight: bold;
      text-align: center;
      box-shadow: 0 0 50px #ff0000;
      display: none;
      z-index: 200;
      animation: pulse 0.5s infinite alternate;
    }

    @keyframes pulse {
      from {
        transform: translate(-50%, -50%) scale(1);
      }
      to {
        transform: translate(-50%, -50%) scale(1.05);
      }
    }

    #bossHealthBar {
      position: fixed;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 500px;
      height: 30px;
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #ff0000;
      display: none;
      z-index: 50;
    }

    #bossHealthFill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ff6600);
      transition: width 0.3s;
    }

    #bossLabel {
      position: fixed;
      top: 25px;
      left: 50%;
      transform: translateX(-50%);
      color: #ff0000;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 20px #ff0000;
      display: none;
      z-index: 50;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="ui">
    Score: <span id="score">0</span><br>
    Coins: <span id="coins">0</span><br>
    Wave: <span id="wave">1</span><br>
    Kills: <span id="kills">0</span><br>
    [B] Build Turret (25) | [R] Reload | [U] Upgrades
  </div>

  <div id="ammoDisplay">
    <span id="ammo">30</span>/30
  </div>

  <div id="scoreboard">
    <h3>üèÜ HIGH SCORES</h3>
    <div id="scoreList"></div>
  </div>

  <div id="bossWarning">‚ö†Ô∏è BOSS INCOMING ‚ö†Ô∏è</div>
  <div id="bossLabel">BOSS</div>
  <div id="bossHealthBar">
    <div id="bossHealthFill"></div>
  </div>

  <div id="upgradeMenu">
    <h2 style="color: #00ffff; margin-top: 0;">UPGRADE SHOP</h2>
    <div style="margin: 20px 0;">
      <button id="upgradeDamage">
        Increase Damage (50 coins)<br>
        <small>Current: <span id="dmgLevel">1</span></small>
      </button><br>
      <button id="upgradeSpeed">
        Increase Speed (40 coins)<br>
        <small>Current: <span id="spdLevel">5</span></small>
      </button><br>
      <button id="upgradeAmmo">
        Max Ammo +10 (60 coins)<br>
        <small>Current: <span id="ammoLevel">30</span></small>
      </button><br>
      <button id="upgradeFireRate">
        Fire Rate (70 coins)<br>
        <small>Current: <span id="fireLevel">150ms</span></small>
      </button><br>
      <button id="upgradeMultiShot">
        Multi-Shot (80 coins)<br>
        <small>Bullets: <span id="multiLevel">1</span></small>
      </button>
    </div>
    <button id="closeUpgrade" style="background: #ff3333;">Close [U]</button>
  </div>

  <canvas></canvas>

  <script>
    // Canvas setup
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = innerWidth;
    canvas.height = innerHeight;

    addEventListener("resize", () => {
      canvas.width = innerWidth;
      canvas.height = innerHeight;
    });

    // Mouse tracking
    const mouse = { x: canvas.width / 2, y: canvas.height / 2 };
    addEventListener("mousemove", e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });

    // Game state variables
    let score = 0;
    let coins = 0;
    let lastShot = 0;
    let fireRate = 150;
    let gameOver = false;
    let ammo = 30;
    let maxAmmo = 30;
    let reloading = false;
    let wave = 1;
    let spawnInterval = 900;
    let spawnTimer = null;
    let kills = 0;
    let playerDamage = 1;
    let upgradeMenuOpen = false;
    let multiShot = 1;
    let highScores = [];
    let bossActive = false;
    let bossWave = false;
    let currentBoss = null;
    let waveTimer = null;

    // DOM elements
    const scoreEl = document.getElementById("score");
    const coinsEl = document.getElementById("coins");
    const ammoEl = document.getElementById("ammo");
    const waveEl = document.getElementById("wave");
    const killsEl = document.getElementById("kills");
    const upgradeMenu = document.getElementById("upgradeMenu");
    const ammoDisplay = document.getElementById("ammoDisplay");
    const scoreListEl = document.getElementById("scoreList");
    const bossWarning = document.getElementById("bossWarning");
    const bossHealthBar = document.getElementById("bossHealthBar");
    const bossHealthFill = document.getElementById("bossHealthFill");
    const bossLabel = document.getElementById("bossLabel");

    // Scoreboard functions
    function updateScoreboard() {
      scoreListEl.innerHTML = highScores
        .slice(0, 5)
        .map((entry, index) => 
          `<div class="score-entry">
            <span>#${index + 1}</span>
            <span>${entry.score} pts (W${entry.wave})</span>
          </div>`
        )
        .join('');
    }

    function saveHighScore() {
      highScores.push({ score, wave, kills, date: Date.now() });
      highScores.sort((a, b) => b.score - a.score);
      highScores = highScores.slice(0, 10);
      updateScoreboard();
    }

    updateScoreboard();

    // Player class
    class Player {
      constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.r = 16;
        this.speed = 5;
      }

      update() {
        this.x = Math.max(this.r, Math.min(canvas.width - this.r, this.x));
        this.y = Math.max(this.r, Math.min(canvas.height - this.r, this.y));

        ctx.shadowBlur = 25;
        ctx.shadowColor = "#00ffff";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = "#00ffff";
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // Bullet class
    class Bullet {
      constructor(x, y, a, dmg = 1, fromBoss = false) {
        this.x = x;
        this.y = y;
        this.vx = Math.cos(a) * 10;
        this.vy = Math.sin(a) * 10;
        this.r = 4;
        this.dmg = dmg;
        this.fromBoss = fromBoss;
      }

      update() {
        if (!upgradeMenuOpen) {
          this.x += this.vx;
          this.y += this.vy;
        }

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = this.fromBoss ? "#ff0000" : "white";
        ctx.fill();
      }
    }

    // Enemy class
    class Enemy {
      constructor(big = false) {
        this.big = big;
        this.x = Math.random() * canvas.width;
        this.y = -40;
        this.r = big ? 28 : 15;
        this.hp = big ? 5 : 1;
        this.speed = big ? 1.1 : 1.8;
      }

      update() {
        const a = Math.atan2(player.y - this.y, player.x - this.x);

        if (!upgradeMenuOpen) {
          this.x += Math.cos(a) * this.speed;
          this.y += Math.sin(a) * this.speed;
        }

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = this.big ? "#5a189a" : "#b00020";
        ctx.fill();

        if (this.big) {
          const barWidth = this.r * 2;
          const barHeight = 4;
          const healthPercent = this.hp / 5;

          ctx.fillStyle = "#333";
          ctx.fillRect(this.x - this.r, this.y - this.r - 8, barWidth, barHeight);
          ctx.fillStyle = "#0f0";
          ctx.fillRect(this.x - this.r, this.y - this.r - 8, barWidth * healthPercent, barHeight);
        }
      }
    }

    // Boss class
    class Boss {
      constructor(waveNum) {
        this.x = canvas.width / 2;
        this.y = -80;
        this.targetY = canvas.height * 0.25;
        this.bossNumber = Math.floor(waveNum / 5);
        this.r = Math.min(60, 45 + this.bossNumber * 3);
        this.maxHp = 50 + this.bossNumber * 30;
        this.hp = this.maxHp;
        this.speed = 2;
        this.shootCooldown = 0;
        this.shootRate = Math.max(30, 80 - this.bossNumber * 8);
        this.bulletCount = Math.min(8, 2 + Math.floor(this.bossNumber / 2));
        this.moveTimer = 0;
        this.moveDirection = 1;
        this.entering = true;
      }

      update() {
        if (this.entering) {
          if (this.y < this.targetY) {
            this.y += 3;
          } else {
            this.entering = false;
          }
        } else {
          if (!upgradeMenuOpen) {
            this.moveTimer++;
            if (this.moveTimer > 60) {
              this.moveDirection = Math.random() > 0.5 ? 1 : -1;
              this.moveTimer = 0;
            }
            this.x += this.speed * this.moveDirection;
            this.x = Math.max(this.r + 20, Math.min(canvas.width - this.r - 20, this.x));
          }
        }

        ctx.shadowBlur = 30;
        ctx.shadowColor = "#ff0000";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = "#8b0000";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r * 0.6, 0, Math.PI * 2);
        ctx.fillStyle = "#ff0000";
        ctx.fill();
        ctx.shadowBlur = 0;

        bossHealthFill.style.width = (this.hp / this.maxHp * 100) + '%';

        if (!upgradeMenuOpen && !this.entering) {
          this.shootCooldown--;
          if (this.shootCooldown <= 0) {
            this.shoot();
            this.shootCooldown = this.shootRate;
          }
        }
      }

      shoot() {
        const angleStep = (Math.PI * 2) / this.bulletCount;
        for (let i = 0; i < this.bulletCount; i++) {
          const angle = angleStep * i + (Date.now() / 1000);
          bullets.push(new Bullet(this.x, this.y, angle, 1, true));
        }
      }
    }

    // Coin class
    class Coin {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.r = 10;
      }

      update() {
        if (Math.hypot(this.x - player.x, this.y - player.y) < 50) {
          coins++;
          coinsEl.textContent = coins;
          return true;
        }

        ctx.shadowBlur = 15;
        ctx.shadowColor = "gold";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = "gold";
        ctx.fill();
        ctx.shadowBlur = 0;
        return false;
      }
    }

    // Turret class
    class Turret {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.cooldown = 0;
        this.durability = 50;
        this.maxDurability = 50;
      }

      update() {
        ctx.fillStyle = "#888";
        ctx.fillRect(this.x - 10, this.y - 10, 20, 20);

        const barWidth = 20;
        const barHeight = 3;
        const healthPercent = this.durability / this.maxDurability;

        ctx.fillStyle = "#333";
        ctx.fillRect(this.x - 10, this.y + 12, barWidth, barHeight);
        ctx.fillStyle = "#0f0";
        ctx.fillRect(this.x - 10, this.y + 12, barWidth * healthPercent, barHeight);

        if (upgradeMenuOpen) return;
        if (this.cooldown-- > 0) return;

        let closest = null;
        let dist = Infinity;

        if (currentBoss) {
          const d = Math.hypot(currentBoss.x - this.x, currentBoss.y - this.y);
          if (d < 400) {
            closest = currentBoss;
            dist = d;
          }
        }

        if (!closest) {
          enemies.forEach(e => {
            const d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < dist) {
              dist = d;
              closest = e;
            }
          });
        }

        if (closest && dist < 400) {
          const a = Math.atan2(closest.y - this.y, closest.x - this.x);
          bullets.push(new Bullet(this.x, this.y, a));
          this.cooldown = 40;
          this.durability--;
        }
      }
    }

    // Game objects
    const player = new Player();
    const bullets = [];
    const enemies = [];
    const coinsArr = [];
    const turrets = [];
    const keys = {};

    // Keyboard input
    addEventListener("keydown", e => {
      if (gameOver && e.code === "Space") {
        e.preventDefault();
        restartGame();
        return;
      }

      keys[e.key.toLowerCase()] = true;

      if (gameOver && e.key.toLowerCase() === "r" && coins >= 50) {
        e.preventDefault();
        coins -= 50;
        coinsEl.textContent = coins;
        gameOver = false;

        for (let i = enemies.length - 1; i >= 0; i--) {
          const dist = Math.hypot(enemies[i].x - player.x, enemies[i].y - player.y);
          if (dist < 200) enemies.splice(i, 1);
        }

        ammo = Math.min(maxAmmo, ammo + 15);
        ammoEl.textContent = ammo;
        ammoDisplay.classList.remove('low');
        return;
      }

      if (gameOver) return;

      if (e.key.toLowerCase() === "r" && !upgradeMenuOpen) reload();
      if (e.key.toLowerCase() === "u") toggleUpgradeMenu();

      if (e.key.toLowerCase() === "b" && coins >= 25 && !upgradeMenuOpen) {
        coins -= 25;
        coinsEl.textContent = coins;
        turrets.push(new Turret(player.x, player.y));
      }
    });

    addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
    addEventListener("mousedown", shoot);

    // Shooting function
    function shoot() {
      if (reloading || ammo <= 0 || gameOver) return;

      const now = Date.now();
      if (now - lastShot < fireRate) return;

      lastShot = now;
      const baseAngle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

      if (multiShot === 1) {
        bullets.push(new Bullet(player.x, player.y, baseAngle, playerDamage));
      } else if (multiShot === 2) {
        bullets.push(new Bullet(player.x, player.y, baseAngle - 0.1, playerDamage));
        bullets.push(new Bullet(player.x, player.y, baseAngle + 0.1, playerDamage));
      } else if (multiShot === 3) {
        bullets.push(new Bullet(player.x, player.y, baseAngle - 0.15, playerDamage));
        bullets.push(new Bullet(player.x, player.y, baseAngle, playerDamage));
        bullets.push(new Bullet(player.x, player.y, baseAngle + 0.15, playerDamage));
      } else {
        bullets.push(new Bullet(player.x, player.y, baseAngle - 0.2, playerDamage));
        bullets.push(new Bullet(player.x, player.y, baseAngle - 0.07, playerDamage));
        bullets.push(new Bullet(player.x, player.y, baseAngle + 0.07, playerDamage));
        bullets.push(new Bullet(player.x, player.y, baseAngle + 0.2, playerDamage));
      }

      ammo--;
      ammoEl.textContent = ammo;

      if (ammo <= 5) {
        ammoDisplay.classList.add('low');
      } else {
        ammoDisplay.classList.remove('low');
      }
    }

    // Reload function
    function reload() {
      if (reloading || ammo === maxAmmo) return;

      reloading = true;
      setTimeout(() => {
        ammo = maxAmmo;
        ammoEl.textContent = ammo;
        ammoDisplay.classList.remove('low');
        reloading = false;
      }, 1500);
    }

    // Toggle upgrade menu
    function toggleUpgradeMenu() {
      upgradeMenuOpen = !upgradeMenuOpen;
      upgradeMenu.style.display = upgradeMenuOpen ? 'block' : 'none';
    }

    // Upgrade button event listeners
    document.getElementById('upgradeDamage').addEventListener('click', () => {
      if (coins >= 50) {
        coins -= 50;
        playerDamage++;
        coinsEl.textContent = coins;
        document.getElementById('dmgLevel').textContent = playerDamage;
      }
    });

    document.getElementById('upgradeSpeed').addEventListener('click', () => {
      if (coins >= 40) {
        coins -= 40;
        player.speed += 0.5;
        coinsEl.textContent = coins;
        document.getElementById('spdLevel').textContent = player.speed.toFixed(1);
      }
    });

    document.getElementById('upgradeAmmo').addEventListener('click', () => {
      if (coins >= 60) {
        coins -= 60;
        maxAmmo += 10;
        ammo = maxAmmo;
        coinsEl.textContent = coins;
        ammoEl.textContent = ammo;
        document.getElementById('ammoLevel').textContent = maxAmmo;
      }
    });

    document.getElementById('upgradeFireRate').addEventListener('click', () => {
      if (coins >= 70 && fireRate > 50) {
        coins -= 70;
        fireRate -= 20;
        coinsEl.textContent = coins;
        document.getElementById('fireLevel').textContent = fireRate + 'ms';
      }
    });

    document.getElementById('upgradeMultiShot').addEventListener('click', () => {
      if (coins >= 80 && multiShot < 4) {
        coins -= 80;
        multiShot++;
        coinsEl.textContent = coins;
        document.getElementById('multiLevel').textContent = multiShot;
      }
    });

    document.getElementById('closeUpgrade').addEventListener('click', toggleUpgradeMenu);

    // Restart game function
    function restartGame() {
      score = 0;
      coins = 0;
      wave = 1;
      kills = 0;
      ammo = 30;
      maxAmmo = 30;
      fireRate = 150;
      playerDamage = 1;
      multiShot = 1;
      gameOver = false;
      reloading = false;
      upgradeMenuOpen = false;
      bossActive = false;
      bossWave = false;
      currentBoss = null;

      player.x = canvas.width / 2;
      player.y = canvas.height / 2;
      player.speed = 5;

      bullets.length = 0;
      enemies.length = 0;
      coinsArr.length = 0;
      turrets.length = 0;

      scoreEl.textContent = score;
      coinsEl.textContent = coins;
      waveEl.textContent = wave;
      killsEl.textContent = kills;
      ammoEl.textContent = ammo;
      document.getElementById('dmgLevel').textContent = playerDamage;
      document.getElementById('spdLevel').textContent = player.speed.toFixed(1);
      document.getElementById('ammoLevel').textContent = maxAmmo;
      document.getElementById('fireLevel').textContent = fireRate + 'ms';
      document.getElementById('multiLevel').textContent = multiShot;

      ammoDisplay.classList.remove('low');
      upgradeMenu.style.display = 'none';
      bossWarning.style.display = 'none';
      bossHealthBar.style.display = 'none';
      bossLabel.style.display = 'none';

      if (waveTimer) clearTimeout(waveTimer);
      if (spawnTimer) clearInterval(spawnTimer);

      startWave();
    }

    // Start wave function
    function startWave() {
      if (spawnTimer) clearInterval(spawnTimer);
      if (waveTimer) clearTimeout(waveTimer);

      if (wave % 5 === 0) {
        bossWave = true;
        bossWarning.style.display = 'block';

        setTimeout(() => {
          bossWarning.style.display = 'none';
          currentBoss = new Boss(wave);
          bossActive = true;
          bossHealthBar.style.display = 'block';
          bossLabel.style.display = 'block';
        }, 2000);
      } else {
        bossWave = false;
        spawnInterval = Math.max(300, 900 - (wave * 50));
        const bigChance = Math.min(0.5, 0.15 + (wave * 0.03));

        spawnTimer = setInterval(() => {
          enemies.push(new Enemy(Math.random() < bigChance));
        }, spawnInterval);

        waveTimer = setTimeout(nextWave, 45000);
      }
    }

    // Next wave function
    function nextWave() {
      wave++;
      waveEl.textContent = wave;
      startWave();
    }

    startWave();

    // Movement function
    function move() {
      if (upgradeMenuOpen || gameOver) return;

      if (keys.w) player.y -= player.speed;
      if (keys.s) player.y += player.speed;
      if (keys.a) player.x -= player.speed;
      if (keys.d) player.x += player.speed;
    }

    // Main animation loop
    function animate() {
      if (gameOver) {
        ctx.fillStyle = "#fff";
        ctx.font = "48px Segoe UI";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 40);

        ctx.font = "24px Segoe UI";
        ctx.fillText(
          `Final Score: ${score} | Wave: ${wave} | Kills: ${kills}`,
          canvas.width / 2,
          canvas.height / 2 + 10
        );

        if (coins >= 50) {
          ctx.fillStyle = "#00ff00";
          ctx.font = "28px Segoe UI";
          ctx.fillText(
            "Press [R] to Revive (50 coins)",
            canvas.width / 2,
            canvas.height / 2 + 60
          );
        } else {
          ctx.fillStyle = "#888";
          ctx.font = "20px Segoe UI";
          ctx.fillText(
            "Not enough coins to revive (need 50)",
            canvas.width / 2,
            canvas.height / 2 + 60
          );
        }

        ctx.fillStyle = "#00ffff";
        ctx.font = "28px Segoe UI";
        ctx.fillText(
          "Press [SPACE] to Restart",
          canvas.width / 2,
          canvas.height / 2 + 110
        );

        ctx.textAlign = "left";
        requestAnimationFrame(animate);
        return;
      }

      // Clear canvas with fade effect
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      move();
      player.update();

      // Update boss
      if (currentBoss && bossActive) {
        currentBoss.update();
      }

      // Update turrets
      turrets.forEach((t, ti) => {
        t.update();
        if (t.durability <= 0 && !upgradeMenuOpen) {
          turrets.splice(ti, 1);
        }
      });

      // Update bullets
      bullets.forEach((b, bi) => {
        b.update();

        // Check boss bullet collision with player
        if (b.fromBoss && Math.hypot(b.x - player.x, b.y - player.y) < b.r + player.r) {
          bullets.splice(bi, 1);
          if (!gameOver) {
            gameOver = true;
            saveHighScore();
            bossHealthBar.style.display = 'none';
            bossLabel.style.display = 'none';
          }
        }

        // Remove bullets that go off screen
        if (!upgradeMenuOpen && (b.x < 0 || b.y < 0 || b.x > canvas.width || b.y > canvas.height)) {
          bullets.splice(bi, 1);
        }
      });

      // Boss collision detection
      if (currentBoss && bossActive && !upgradeMenuOpen) {
        bullets.forEach((b, bi) => {
          if (!b.fromBoss && Math.hypot(currentBoss.x - b.x, currentBoss.y - b.y) < currentBoss.r + b.r) {
            bullets.splice(bi, 1);
            currentBoss.hp -= b.dmg;

            if (currentBoss.hp <= 0) {
              bossActive = false;
              currentBoss = null;
              bossHealthBar.style.display = 'none';
              bossLabel.style.display = 'none';
              score += 200;
              kills++;
              scoreEl.textContent = score;
              killsEl.textContent = kills;

              // Drop coins
              for (let i = 0; i < 10; i++) {
                coinsArr.push(new Coin(
                  canvas.width / 2 + (Math.random() - 0.5) * 100,
                  canvas.height * 0.25 + (Math.random() - 0.5) * 100
                ));
              }

              setTimeout(() => {
                wave++;
                waveEl.textContent = wave;
                startWave();
              }, 2000);
            }
          }
        });
      }

      // Update enemies
      enemies.forEach((e, ei) => {
        e.update();

        // Check enemy collision with player
        if (!upgradeMenuOpen && Math.hypot(e.x - player.x, e.y - player.y) < e.r + player.r && !gameOver) {
          gameOver = true;
          saveHighScore();
        }

        // Check bullet collision with enemies
        if (!upgradeMenuOpen) {
          bullets.forEach((b, bi) => {
            if (!b.fromBoss && Math.hypot(e.x - b.x, e.y - b.y) < e.r + b.r) {
              bullets.splice(bi, 1);
              e.hp -= b.dmg;

              if (e.hp <= 0) {
                enemies.splice(ei, 1);
                kills++;
                score += e.big ? 30 : 10;
                scoreEl.textContent = score;
                killsEl.textContent = kills;

                // Drop coins
                if (e.big) {
                  for (let i = 0; i < 3; i++) {
                    coinsArr.push(new Coin(
                      e.x + (Math.random() - 0.5) * 30,
                      e.y + (Math.random() - 0.5) * 30
                    ));
                  }
                } else {
                  coinsArr.push(new Coin(e.x, e.y));
                }
              }
            }
          });
        }
      });

      // Update coins
      coinsArr.forEach((c, ci) => {
        if (c.update()) {
          coinsArr.splice(ci, 1);
        }
      });

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
